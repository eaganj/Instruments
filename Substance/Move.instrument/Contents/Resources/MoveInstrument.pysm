from IIKit import *

import jre.debug
import jre.geom as geom

from IIKit.plugin.fr.lri.eaganj.instrument.substance.HoveringPointer.HoveringPointerInstrument import HoveringPointerInstrument

from StateMachines import statemachine

BUTTON1='button1'

class MoveInstrument(HoveringPointerInstrument):
    '''
    A very simple instrument that lets the user move an object when a button is pressed.
    '''
    
    name = u"Move Tool" # FIXME refactor
    verb = u"Move objects"
    priority = 0

    # FIXME: we call our start state "hovering" but it doesn't mean that.
    State hovering:
        Transition press(self, ButtonPress, device="<bound>", guard=lambda event: event.binding == BUTTON1 and self._hoverGuard(event)) >> self.moving:
    # State start:
    #     Transition point(self, Pointing, guard=self._hoverGuard) >> self.hovering:
    #         pass
    # 
    # State hovering:
    #     Transition unhover(self, Pointing, guard=lambda event: not self.isHovering(event)) >> self.start:
    #         pass
    #     
    #     Transition press(self, ButtonPress) >> self.moving:
            point = self._cursor.get_value(self, "position")
            target = self.getObjectAtPoint(point)
            
            stacking_order = self.sg.get_value(self, "stacking_order")
            try:
                stacking_order.remove(target.node_name())
            except IndexError:
                pass
            stacking_order.insert(0, target.node_name())
            self.sg.stacking_order = self, stacking_order
            
            self._target = target
            self._offset = (0, 0)
            self._lastPoint = point
                
    State moving:
        Transition move(self, Pointing, device="<bound>"):
            cursorPoint = self._cursor.get_value(self, "position")
            dx, dy = geom.delta(self._lastPoint, cursorPoint)
            tx, ty = map(float, self._target.get_value(self, "position"))
            newPoint = (tx + dx, ty + dy)
            # self.moveObjectWithOffsetTo(self._target, self._offset, newPoint)
            self.moveObjectTo(self._target, newPoint)
            self._lastPoint = cursorPoint

        Transition release(self, ButtonRelease, device="<bound>", guard=lambda event: event.binding == BUTTON1) >> self.hovering:
            pass
            
        # Transition releaseHover(self, ButtonRelease, device="<bound>", guard=lambda event: event.binding == BUTTON1 and self.isHovering(event)) >> self.hovering:
        #     pass
        
        # Transition release(self, ButtonRelease, device="<bound>", guard=lambda event: event.binding == BUTTON1) >> self.start:
        #     pass
    
    
    def moveObjectWithOffsetTo(self, obj, offset, point):
        x, y = point
        ox, oy = offset
        self.moveObjectTo(obj, (x + ox, y + oy))
    
    def moveObjectTo(self, obj, point):
        obj.position = self, point